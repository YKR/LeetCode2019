# LeetCode2019 0101-0200

- [X] 0101

|递归|
|:--|
|判断是否对称，同时处理左子树和右子树即可|

- [X] 0102

|广度优先搜索|
|:--|
|普通的BFS|

- [X] 0103

|广度优先搜索|
|:--|
|其实是用栈实现的广度优先搜索，本层结点弹栈，下一层的结点压到另一个栈里。需要注意奇数层和偶数层left/right的压栈顺序相反|

- [X] 0104

|递归|
|:--|
|求二叉树的层数，递归解决即可
这可能是LeetCode上我行数最少、写得最快的程序了|

- [X] 0105

|二叉树遍历，递归|
|:--|
|根据先序遍历和中序遍历重建二叉树，注意先序遍历序列的第一个元素是树的根结点，在中序遍历序列中找到对应结点后可以确定左子树的序列和右子树的序列，递归解决即可|

- [X] 0106

|二叉树遍历，递归|
|:--|
|跟上题几乎一样，只是先序遍历换成了后序遍历|

- [X] 0107

|广度优先搜索|
|:--|
|奇怪的要求……我的做法是先用dfs求出树的高度，再广搜并反向填充返回值|

- [X] 0108

|二分，平衡BST|
|:--|
|题目说是构建平衡BST，但其实输入数据是有序的，没必要写旋转之类的操作，直接二分建树即可（因为左右子树结点数相差不超过1，且各自是平衡BST（归纳假设），故它们的高度差也不超过1，满足平衡条件）|

- [X] 0109

|二分，平衡BST|
|:--|
|只是把上题的输入数组换成了链表。事实上手写AVL的效率大概是O(nlogn)，转换成数组后用上题的方法效率是O(n)，还优于前者|

- [X] 0110

|平衡树|
|:--|
|判断一棵树是否平衡。递归查询它左右子树高度即可|

- [X] 0111

|递归|
|:--|
|求二叉树子树的最小高度，容易踩坑的一点是当左/右子树为空的时候应该忽略它们，而不是将它们当作高度为0的树|

- [X] 0112

|递归|
|:--|
|递归求根结点到叶结点的数值和，判断其是否等于给定数值。没什么可说的|

- [X] 0113

|递归|
|:--|
|题目要求跟上一题基本相同，输出改成了所有符合条件的路径。递归求解即可|

- [X] 0114

|递归|
|:--|
|题目要求将二叉树根据先序遍历顺序重排成链表，还要求In-place
实际做法就是递归，将左子树重排后放在右指针上，右子树重排后放在链表尾部|

- [X] 0115

|动态规划，最长公共子序列|
|:--|
|最长公共子序列的变种，递推方程：
`f[i][j] = f[i - 1][j], if s[i - 1] != t[i - 1]`
`f[i][j] = f[i - 1][j] + f[i - 1][j - 1], if s[i - 1] == t[i - 1]`|

- [X] 0116

|递归|
|:--|
|除了栈空间外不能用额外的空间，那么这样设计递归即可：
`populateNext(currentNode, predecessorNode, successorNode)`
`>>>predecessorNode->next = currentNode`
`>>>currentNode->next = successorNode`
`>>>populateNext(currentNode->left, predecessorNode->right, currentNode->right)`
`>>>populateNext(currentNode->right, currentNode->left, successorNode->left)`
其中predecessorNode表示在currentNode之前紧邻它的结点，successorNode表示在currentNode之后紧邻它的结点。因为保证输入二叉树是完全二叉树，所以递归过程保持了紧邻这一性质|

- [X] 0117

|递归|
|:--|
|除了“保证输入二叉树是完全二叉树”之外，跟上一题完全相同
分析题意，查找一个结点x的next成员可以利用其父结点p的next，在p的右侧查找第一个含有子结点的结点p'，记p'的第一个子结点为c，则c应为x的next成员。算法设计如下：
`populateNext(currentNode, parentNode)`
`>>>currentNode->next = firstChild(findNearest(parentNode))`
`>>>populateNext(currentNode->right, currentNode)`
`>>>populateNext(currentNode->left, currentNode)`
注意递归过程中应先递归right，因为要保证parentNode及其右侧结点的next成员是正确的，否则可能出现错漏|

- [X] 0118

|模拟|
|:--|
|纯模拟，按题意写即可|

- [X] 0119

|组合|
|:--|
|帕斯卡三角形的每一行是对应幂次二项展开的系数，即每一项都是C(x, y)。编写函数求出C(x, y)即可|

- [X] 0120

|动态规划|
|:--|
|除了数组形状有点不同，就是一个简单的二维DP|

- [X] 0121

|模拟|
|:--|
|`f[i] = prices[i] - min{prices[j], 0 <= j < i}`|

- [X] 0122

|贪心|
|:--|
|只需要做短线投资即可，若后一天股票价格 <= 前一天价格，则前一天不买入，否则买入并在后一天卖出。可证明短线投资恒优于长线投资|

- [X] 0123

|预处理，动态规划|
|:--|
|问题分解为2个0121（从左边开始 / 从右边开始），分别预处理出答案，然后枚举分界点即可。复杂度O(n + n + n) = O(n)
扩展到只允许T次买入卖出的情况，其实相当于动态规划：
`f[t][i] = max{f[t][i - 1], f[t - 1][j] + prices[i] - prices[j], j <= i}`
此时时间复杂度O(T * n ^ 2)
观察递推式，将其变为：
`f[t][i] = max{f[t][i - 1], prices[i] + max{f[t - 1][j] - prices[j], j <= i}}`
则含有j的部分可以在遍历i时顺带求出，复杂度O(T * n)|

- [X] 0124

|递归|
|:--|
|首先递归求最大路径和：
`pathSum(node) = max{pathSum(node->left) + node->val, pathSum(node->right) + node->val, node->val}`
在递归过程中加入语句：
`ans = max{pathSum(node), pathSum(node->left) + pathSum(node->right) + node->val}`
则可求出答案（答案既可能是某个结点的最大路径和，也可能是某结点左右最大路径和之和）|

- [X] 0125

|字符串|
|:--|
|忽略非字母和数字的字符，所有字母忽略大小写，判断字符串是否是回文串。按题意写即可|

- [X] 0126

|字符串，最短路（BFS）|
|:--|
|需要自己根据题目条件建图，在图上求最短路。因为边长都是1，后者可以用BFS解决
注意题目条件，比如endWord必须在wordList中出现等。而且这题卡时间卡得比较紧，邻接矩阵会超时，只能用边表
求出最短距离后，最短路径通过DFS求出（每次找距离+1的结点，遇到endWord就返回）|

- [X] 0127

|字符串，最短路（BFS）|
|:--|
|同上题，只不过只要求输出最短距离。复制代码稍微修改一下即可|

- [X] 0128

|哈希表|
|:--|
|O(n)的要求看起来很吓人，但是仔细一想同等或优于O(n)的算法只有那么几个，很容易联想到桶排序和哈希。因为没有限定nums数组中数值的大小，普通桶排不可行，只能用unordered_set / unordered_map等哈希方法来做
在一开始的方法中我还使用了并查集来计算数字块的大小（记错了并查集的复杂度，虽然近似O(1)但严格来说不是），确认并查集复杂度后参考了官方题解，也就是遍历nums数组，一旦找到一个数字块的边界（如找不到nums[i] - 1的情况）就将其向另一个边界扩展（nums[i] + 1，nums[i] + 2，...）这样就能在O(n)时间内求出答案了|

- [X] 0129

|递归|
|:--|
|普通递归题，递归到叶节点时更新答案即可|

- [X] 0130

|漫水填充|
|:--|
|普通的漫水填充题，填充两次，第一次测试是否能填，第二次实际填充|

- [X] 0131

|搜索|
|:--|
|预处理出可能的回文串后，直接DFS搜索即可|

- [X] 0132

|动态规划|
|:--|
|递推方程`f[i] = min{f[j - 1] + 1, s(i, j) is a palindrome}`|

- [X] 0133

|映射|
|:--|
|题意是复制一个图结构。DFS复制过程中会遇到成环的情况，解决它的办法是建立原图结点与新图结点的对应关系，每次访问一个原图结点时，若已有对应的新图结点则直接返回之，否则建立一个新图结点并建立它与其他结点的联系|

- [X] 0134

|模拟？，最小值，循环和问题|
|:--|
|可以直接根据输入计算出使用当前站的油到达下一站后的剩余油量（可能为负数）。从某一站开始的累积油量通过计算剩余油量的和得到，一旦中途出现负数则当前始发站不可行。这样的算法时间复杂度为O(n ^ 2)
观察累积油量计算过程，在递增始发站的过程中大部分元素都有一致的变化，除了去掉了开头的元素，增加了末尾的元素外，所有中间元素都减去了开头元素的剩余油量。那么，维护一个记录累积油量最小值的变量，它只需要每次减去剩余油量后与末尾元素比较大小即可。而新增的末尾元素即全部的累计油量恒等于所有站的剩余油量之和，故给定输入的情况下它是一个常量。这个方法的时间复杂度为O(n)
这个方法其实留下了一个问题，就是某一次累积油量最小的变量是开头的元素，被弹出去了怎么办？此时此方法得到的累积油量最小值等于0，因为它是最小的，中间的元素也都大于或等于0，只要末尾元素不小于0即满足条件返回，否则累积油量最小值更新为末尾元素。故在这种情况下，答案也是正确的|

- [X] 0135

|拓扑排序|
|:--|
|可以把问题转换成拓扑排序：元素向与它相邻并比它大的元素连单向边，建完图后拓扑排序求结果
具体到这一题，有一种不需要写完整拓扑排序的方法：从左到右遍历，若元素大于左边元素，则当前元素的左Candy数 = 左边元素左Candy数 + 1，否则 = 1；从右到左遍历，若元素大于右边元素，则当前元素的右Candy数 = 右边元素右Candy数 + 1，否则 = 1；元素Candy数 = max(左Candy数，右Candy数)。这样做可以得到正确结果，是因为除了“山峰”外其他元素只有一条入边|

- [X] 0136

|哈希，位运算|
|:--|
|一开始的想法是利用哈希充当桶排序的工具，如果出现两次则消除，最后哈希表中剩下的唯一一个就是答案
但是题目要求O(n)时间复杂度和O(1)空间复杂度。仔细想了想，一个数异或另一个数两次则还是原来那个数，那么只需要用0依次异或nums的所有元素，得到的结果就是答案了|

- [X] 0137

|哈希，位运算（扩展）|
|:--|
|同上题一样，可以使用哈希方法求得最终答案
同样要求O(n)时间和O(1)空间时，需要构造运算，使得0@X = X@0 = X，X@X@X = 0，且X@AB...CD@X@EF...GH@X = AB..CD@EF..GH。一开始考虑矩阵乘法，未果；注意到模空间（X%3）中的{0, 1, 2}满足此运算条件，依据此特点将nums中的所有数分解为二进制表示，计算每一位上的和，再将它们分别取模，剩下的二进制数即为单独的那个数（特别地，nums中某个数二进制表示的第Y位为0或1，那么任何出现过三次的数在这一位上的和%3 == 0，出现一次的数在这一位上的和%3 == 原来的值，故所有数在这一位上的和%3 == 出现一次的数在这一位上原来的值）
反过来看上一题的异或操作，其实在每一位上，也相当于取模操作（X0[Y] ^ X1[Y] == (X0[Y] + X1[Y]) % 2，其中X[Y]代表X二进制表示的第Y位）
注意这一题的操作也可以应用到数字的三进制表示，同样可以得到正确结果|

- [X] 0138

|映射|
|:--|
|本质上跟之前的0133是一样的，在结构上还更简单一点，可以用数组来处理|

- [X] 0139

|字符串，搜索，动态规划|
|:--|
|递推式`f[i] = f[j0] or f[j1] or f[j2] or ... or f[jK], jX < i && s(jX, i) in wordDict`，故可以用动态规划或DFS来做
不过因为需要匹配字符串，我这里用Trie树稍微优化了动态规划的效率。
也可以用Trie + DFS来做。这个方法需要剪枝掉最有可能耗时的搜索支，即当某个子串有很多个组成方式时，此子串后面的串被重复搜索多次|

- [X] 0140

|字符串，搜索|
|:--|
|跟上一题同样的题干，不过求的是所有可行方案的集合。采用上一题的搜索策略
本来加了剪枝，但是在修改搜索函数的过程中少加了一句“记录后面的串都不可行”，结果TLE了一次……有点坑啊，这还是之前那个TOO MUCH WATER的LeetCode吗？|

- [X] 0141

|链表|
|:--|
|寻找链表中的环，一般情况下用栈可以轻松解决。不过题目要求O(1)空间，故可以使用两个指针以不同的速度遍历链表，一旦快的指针追上慢的指针，则链表中有环
关于时间复杂度，因为我的快指针速度是慢指针的两倍，故慢指针最多遍历(n + (2 - 1) * 环中结点数量) <= 2 * n个结点，故最坏时间复杂度是O(n)的，是理论最优值|

- [X] 0142

|链表|
|:--|
|寻找链表中环的开始位置，同样要求O(1)空间
判断是否有环可以使用上题的代码；找环的开始位置则可以这样做：首先利用判断时留下来的指针求出[环的长度]，然后从链表头开始使用两个间隔为[环的长度]的指针扫描链表，一旦它们相遇则相遇点就是环开始的位置。最坏时间复杂度 = O(n) + O(环中结点数量 + n - 环中结点数量) = O(n)，是最优的|

- [X] 0143

|链表|
|:--|
|这题没什么O(1)空间之类的限制，所以直接用数组记录链表即可|

- [X] 0144

|二叉树遍历|
|:--|
|要求用循环实现先序遍历，那么用栈模拟递归即可。每次弹栈时输出，并依次将右孩子和左孩子压入栈中（后进先出，应先输出左子树，故应后压入左孩子），直到栈为空为止|

- [X] 0145

|二叉树遍历|
|:--|
|要求用循环实现后序遍历，还是用栈模拟递归即可。这里我取了个巧，先求后序遍历的反序输出（每次弹栈时输出，并依次将左孩子和右孩子压入栈中；注意压栈顺序和上一题相反），然后返回再次反序的结果|

- [X] 0146

|LRU缓存|
|:--|
|题目要求实现LRU，且存取都要是O(1)的。Python和Java里有OrderedDict / LinkedHashMap，然而C++ STD里应该是没有的……
这里我使用list保存key-value对，使用unordered_map建立key到list元素的映射。由于list迭代器的性质（改变其他元素不会影响当前元素），增删list中的一个元素后unordered_map中只有key受影响的元素需要被修改。这样，存的效率为（list减少元素 + list增加元素 + unordered_map减少元素 + unordered_map增加元素），即O(1)；取的效率为（unordered_map寻找元素 + list移动元素），也即O(1)
实现时需要注意一点，存操作时先取一下，如果key已经存在了，改变value即可。不这样做可能造成list中有重复的key、误弹出不应被弹出的块等|

- [X] 0147

|插入排序，链表|
|:--|
|在单向链表上实现插入排序。按定义来就行|

- [X] 0148

|归并排序，链表|
|:--|
|要求对单向链表实现时间复杂度O(nlogn)、空间复杂度O(1)的排序算法
想了想果然还是归并。虽然数组版的归并空间复杂度是O(n)，但因为是链表，无需复制元素，只需要修改next就行了，那么空间复杂度完全可以控制在O(1)内。时间上增加了一个找中间元素的时间，但它和归并操作的复杂度是相同的，故时间复杂度还是O(nlogn)|

- [X] 0149

|映射 / 哈希，计算几何|
|:--|
|求点集中最多几点共线
因为两点确定一条直线，时间复杂度有一个基础的O(n ^ 2)。在枚举两点时，可以算出它的斜率（由于可能有精度问题，放弃double，使用唯一向量表示直线的方向，这个唯一向量满足横纵坐标值互质）；那么固定一点，利用map记录它到所有其他点的直线的斜率出现的次数，取max即可求得答案。时间复杂度O(n ^ 2 * logn)
这里可以剪枝，即一条直线命中过的点互相不再求答案，但是不仅写起来麻烦，还增大了常数，实际表现不算好
另外，只要把map改成unordered_map，即可获得理论复杂度O(n ^ 2)
这几道题都有点小麻烦，不像以前那么水了……|

- [X] 0150

|栈|
|:--|
|求后缀表达式的值。按照定义求出即可|

- [ ] 0151

||
|:--|
||

- [ ] 0152

||
|:--|
||

- [ ] 0153

||
|:--|
||

- [ ] 0154

||
|:--|
||

- [ ] 0155

||
|:--|
||

- [ ] 0156

||
|:--|
||

- [ ] 0157

||
|:--|
||

- [ ] 0158

||
|:--|
||

- [ ] 0159

||
|:--|
||

- [ ] 0160

||
|:--|
||

- [ ] 0161

||
|:--|
||

- [ ] 0162

||
|:--|
||

- [ ] 0163

||
|:--|
||

- [ ] 0164

||
|:--|
||

- [ ] 0165

||
|:--|
||

- [ ] 0166

||
|:--|
||

- [ ] 0167

||
|:--|
||

- [ ] 0168

||
|:--|
||

- [ ] 0169

||
|:--|
||

- [ ] 0170

||
|:--|
||

- [ ] 0171

||
|:--|
||

- [ ] 0172

||
|:--|
||

- [ ] 0173

||
|:--|
||

- [ ] 0174

||
|:--|
||

- [ ] 0175

||
|:--|
||

- [ ] 0176

||
|:--|
||

- [ ] 0177

||
|:--|
||

- [ ] 0178

||
|:--|
||

- [ ] 0179

||
|:--|
||

- [ ] 0180

||
|:--|
||

- [ ] 0181

||
|:--|
||

- [ ] 0182

||
|:--|
||

- [ ] 0183

||
|:--|
||

- [ ] 0184

||
|:--|
||

- [ ] 0185

||
|:--|
||

- [ ] 0186

||
|:--|
||

- [ ] 0187

||
|:--|
||

- [ ] 0188

||
|:--|
||

- [ ] 0189

||
|:--|
||

- [ ] 0190

||
|:--|
||

- [ ] 0191

||
|:--|
||

- [ ] 0192

||
|:--|
||

- [ ] 0193

||
|:--|
||

- [ ] 0194

||
|:--|
||

- [ ] 0195

||
|:--|
||

- [ ] 0196

||
|:--|
||

- [ ] 0197

||
|:--|
||

- [ ] 0198

||
|:--|
||

- [ ] 0199

||
|:--|
||

- [ ] 0200

||
|:--|
||
