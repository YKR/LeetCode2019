# LeetCode2019 0101-0200

- [X] 0101

|递归|
|:--|
|判断是否对称，同时处理左子树和右子树即可|

- [X] 0102

|广度优先搜索|
|:--|
|普通的BFS|

- [X] 0103

|广度优先搜索|
|:--|
|其实是用栈实现的广度优先搜索，本层结点弹栈，下一层的结点压到另一个栈里。需要注意奇数层和偶数层left/right的压栈顺序相反|

- [X] 0104

|递归|
|:--|
|求二叉树的层数，递归解决即可
这可能是LeetCode上我行数最少、写得最快的程序了|

- [X] 0105

|二叉树遍历，递归|
|:--|
|根据先序遍历和中序遍历重建二叉树，注意先序遍历序列的第一个元素是树的根结点，在中序遍历序列中找到对应结点后可以确定左子树的序列和右子树的序列，递归解决即可|

- [X] 0106

|二叉树遍历，递归|
|:--|
|跟上题几乎一样，只是先序遍历换成了后序遍历|

- [X] 0107

|广度优先搜索|
|:--|
|奇怪的要求……我的做法是先用dfs求出树的高度，再广搜并反向填充返回值|

- [X] 0108

|二分，平衡BST|
|:--|
|题目说是构建平衡BST，但其实输入数据是有序的，没必要写旋转之类的操作，直接二分建树即可（因为左右子树结点数相差不超过1，且各自是平衡BST（归纳假设），故它们的高度差也不超过1，满足平衡条件）|

- [X] 0109

|二分，平衡BST|
|:--|
|只是把上题的输入数组换成了链表。事实上手写AVL的效率大概是O(nlogn)，转换成数组后用上题的方法效率是O(n)，还优于前者|

- [X] 0110

|平衡树|
|:--|
|判断一棵树是否平衡。递归查询它左右子树高度即可|

- [X] 0111

|递归|
|:--|
|求二叉树子树的最小高度，容易踩坑的一点是当左/右子树为空的时候应该忽略它们，而不是将它们当作高度为0的树|

- [X] 0112

|递归|
|:--|
|递归求根结点到叶结点的数值和，判断其是否等于给定数值。没什么可说的|

- [X] 0113

|递归|
|:--|
|题目要求跟上一题基本相同，输出改成了所有符合条件的路径。递归求解即可|

- [X] 0114

|递归|
|:--|
|题目要求将二叉树根据先序遍历顺序重排成链表，还要求In-place
实际做法就是递归，将左子树重排后放在右指针上，右子树重排后放在链表尾部|

- [X] 0115

|动态规划，最长公共子序列|
|:--|
|最长公共子序列的变种，递推方程：
`f[i][j] = f[i - 1][j], if s[i - 1] != t[i - 1]`
`f[i][j] = f[i - 1][j] + f[i - 1][j - 1], if s[i - 1] == t[i - 1]`|

- [X] 0116

|递归|
|:--|
|除了栈空间外不能用额外的空间，那么这样设计递归即可：
`populateNext(currentNode, predecessorNode, successorNode)`
`   predecessorNode->next = currentNode`
`   currentNode->next = successorNode`
`   populateNext(currentNode->left, predecessorNode->right, currentNode->right)`
`   populateNext(currentNode->right, currentNode->left, successorNode->left)`
其中predecessorNode表示在currentNode之前紧邻它的结点，successorNode表示在currentNode之后紧邻它的结点。因为保证输入二叉树是完全二叉树，所以递归过程保持了紧邻这一性质|

- [X] 0117

|递归|
|:--|
|除了“保证输入二叉树是完全二叉树”之外，跟上一题完全相同
分析题意，查找一个结点x的next成员可以利用其父结点p的next，在p的右侧查找第一个含有子结点的结点p'，记p'的第一个子结点为c，则c应为x的next成员。算法设计如下：
`populateNext(currentNode, parentNode)`
`   currentNode->next = firstChild(findNearest(parentNode))`
`   populateNext(currentNode->right, currentNode)`
`   populateNext(currentNode->left, currentNode)`
注意递归过程中应先递归right，因为要保证parentNode及其右侧结点的next成员是正确的，否则可能出现错漏|

- [X] 0118

|模拟|
|:--|
|纯模拟，按题意写即可|

- [X] 0119

|组合|
|:--|
|帕斯卡三角形的每一行是对应幂次二项展开的系数，即每一项都是C(x, y)。编写函数求出C(x, y)即可|

- [X] 0120

|动态规划|
|:--|
|除了数组形状有点不同，就是一个简单的二维DP|

- [ ] 0121

||
|:--|
||

- [ ] 0122

||
|:--|
||

- [ ] 0123

||
|:--|
||

- [ ] 0124

||
|:--|
||

- [ ] 0125

||
|:--|
||

- [ ] 0126

||
|:--|
||

- [ ] 0127

||
|:--|
||

- [ ] 0128

||
|:--|
||

- [ ] 0129

||
|:--|
||

- [ ] 0130

||
|:--|
||

- [ ] 0131

||
|:--|
||

- [ ] 0132

||
|:--|
||

- [ ] 0133

||
|:--|
||

- [ ] 0134

||
|:--|
||

- [ ] 0135

||
|:--|
||

- [ ] 0136

||
|:--|
||

- [ ] 0137

||
|:--|
||

- [ ] 0138

||
|:--|
||

- [ ] 0139

||
|:--|
||

- [ ] 0140

||
|:--|
||

- [ ] 0141

||
|:--|
||

- [ ] 0142

||
|:--|
||

- [ ] 0143

||
|:--|
||

- [ ] 0144

||
|:--|
||

- [ ] 0145

||
|:--|
||

- [ ] 0146

||
|:--|
||

- [ ] 0147

||
|:--|
||

- [ ] 0148

||
|:--|
||

- [ ] 0149

||
|:--|
||

- [ ] 0150

||
|:--|
||

- [ ] 0151

||
|:--|
||

- [ ] 0152

||
|:--|
||

- [ ] 0153

||
|:--|
||

- [ ] 0154

||
|:--|
||

- [ ] 0155

||
|:--|
||

- [ ] 0156

||
|:--|
||

- [ ] 0157

||
|:--|
||

- [ ] 0158

||
|:--|
||

- [ ] 0159

||
|:--|
||

- [ ] 0160

||
|:--|
||

- [ ] 0161

||
|:--|
||

- [ ] 0162

||
|:--|
||

- [ ] 0163

||
|:--|
||

- [ ] 0164

||
|:--|
||

- [ ] 0165

||
|:--|
||

- [ ] 0166

||
|:--|
||

- [ ] 0167

||
|:--|
||

- [ ] 0168

||
|:--|
||

- [ ] 0169

||
|:--|
||

- [ ] 0170

||
|:--|
||

- [ ] 0171

||
|:--|
||

- [ ] 0172

||
|:--|
||

- [ ] 0173

||
|:--|
||

- [ ] 0174

||
|:--|
||

- [ ] 0175

||
|:--|
||

- [ ] 0176

||
|:--|
||

- [ ] 0177

||
|:--|
||

- [ ] 0178

||
|:--|
||

- [ ] 0179

||
|:--|
||

- [ ] 0180

||
|:--|
||

- [ ] 0181

||
|:--|
||

- [ ] 0182

||
|:--|
||

- [ ] 0183

||
|:--|
||

- [ ] 0184

||
|:--|
||

- [ ] 0185

||
|:--|
||

- [ ] 0186

||
|:--|
||

- [ ] 0187

||
|:--|
||

- [ ] 0188

||
|:--|
||

- [ ] 0189

||
|:--|
||

- [ ] 0190

||
|:--|
||

- [ ] 0191

||
|:--|
||

- [ ] 0192

||
|:--|
||

- [ ] 0193

||
|:--|
||

- [ ] 0194

||
|:--|
||

- [ ] 0195

||
|:--|
||

- [ ] 0196

||
|:--|
||

- [ ] 0197

||
|:--|
||

- [ ] 0198

||
|:--|
||

- [ ] 0199

||
|:--|
||

- [ ] 0200

||
|:--|
||
