# LeetCode2019 0001-0100

- [X] 0001

|N-Sum问题|
|:--|
|花式过题。基本思路是从大到小排序后，两指针i，j分别从nums的头部和尾部开始扫描
1 如果 nums[i] + nums[j] > target，则++i
2 如果 nums[i] + nums[j] < target，则--j
3 如果相等就返回输出。
上一次的做法是构造(nums[i], i)为元素的vector并快速排序
这一次本来想使用lambda表达式排序，但是爆内存了（可能是Lambda表达式的问题？）
于是利用map是平衡树的特点，把(nums[i], i)塞进树里，随机访问时就已经排好序了（不过map是红黑树，时间效率上差一点）
但是map中不能存在相同的键，所以实际上把它的value类型变成了vector。此时可能会有i == j的情况，需要特殊判断一下|

- [X] 0002

|链表|
|:--|
|链表，没什么算法可写。需要注意边界条件，比如前导0|

- [X] 0003

|字符串|
|:--|
|基本思路是扫描字符串时记录扫描过的字符的位置。
当访问一个新字符x时，递增当前累积子串ss的长度len；若ss中存在x，则将len变为curr[x] - last[x]。每一步用len更新ans
这一次使用了map记录字符位置，时间效率O(nlogn)。事实上用桶排序思路的话（字符只有256个），可以把logn项缩减掉|

- [X] 0004

|二分|
|:--|
|可以手写归并排序，时间O(m+n)，好处是容易写
最优解思路是：令nums1为nums1、nums2中size较小的那一个，目的是从nums1中取出x个数，nums2中取出half-x个数（half是总数的一半），使得取出来的数组成了nums1+nums2中小的一半，此时未取出的数自然是nums1+nums2中大的一半，那么根据有序性至多只需要比较四个数的大小即可
此时可以二分x，故时间为O(log(min(m,n)))。坏处是边界条件很头疼|

- [X] 0005

|动态规划，最长回文子串问题|
|:--|
|一般解法是O(n^2)的，包括上次的暴力枚举对称中心和这次的dp
官方正解里有一个叫[Manacher's Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)的算法
<**TODO**>: 了解并阐述Manacher's Algorithm|

- [X] 0006

|字符串|
|:--|
|纯粹的字符串处理题，就偷懒复制上次的代码了。不过要写得简短有效还是不容易的。|

- [X] 0007

|整数|
|:--|
|简单的数字题，有一点位运算内容。主要问题是在只能使用32位整数时，如何判断溢出
我的解法通过把乘法拆分为左移，对每一步左移做判断来避免溢出。官方正解是判断当前数字与INT_MAX/10的大小
其实可以在汇编里判断溢出标志位吧……|

- [X] 0008

|整数|
|:--|
|相当于上一题的扩展，抛开white space和正负号，还是只能使用32位整数时怎么判断溢出的问题|

- [X] 0009

|整数|
|:--|
|判断回文数字，负数被排除了，如果用“倒序数字”是否等于“原数字”来判断，只需要考虑溢出问题。然而这题没限制32位，直接long long搞定
这题的小要求“不把数字转换成字符串”，那么把数字转成vector也可以吧……|

- [X] 0010

|动态规划|
|:--|
|正则表达式匹配相当于寻找一个自动机状态序列，似乎只能用动态规划？|

- [X] 0011

|贪心|
|:--|
|这次的解法是根据挡板高度从大到小排序，遍历挡板时记录扫描过的挡板的x坐标最大值和最小值，用当前挡板高度乘以（x最大值-x最小值）更新答案。因为扫描到当前挡板时，x坐标最大/最小的挡板的高度一定不低于当前挡板，所以当前答案是可能的；而且确实会枚举到使当前答案=正确答案的情况，所以算法正确。时间复杂度O(nlogn)
更优的做法是一种贪心法。使两指针i，j分别从height头尾开始扫描，当height[i] < height[j]时++i，否则--j；用min(height[i], height[j]) * (j - i)更新答案。这样做一定会列举到正确答案的原因是：当i到达正确答案左边挡板l时，j只可能位于正确答案右边挡板r或之外，否则因为--j的情况只会发生在height[i] >= height[j]时，则存在l' < l且height[l'] >= height[r]，从而(l', r)组成的挡板是更优的解。时间复杂度O(n)|

- [X] 0012

|字符串|
|:--|
|简单模拟，轻松一刻，花式过题|

- [X] 0013

|字符串|
|:--|
|罗马数字转回阿拉伯。遍历字符串，若上一个字符标识的数字小于当前字符的，表示的就是当前字符减上一个字符，就要减去两倍上一个字符的值。|

- [X] 0014

|字符串|
|:--|
|轻松一刻|

- [X] 0015

|N-Sum问题|
|:--|
|这次为了省事又把输入丢到map里去了（map用来排序和记录重复次数）。思路就是枚举两个数a和b，判断-(a+b)是否在nums里
目前的做法是O(n^2logn)的，当然也可以把内循环里map的查找操作换成unordered_map的查找，来强行让复杂度变为O(n^2)
上一次的做法是排序后枚举中间的数i，用两个指针j，k从i开始向左向右遍历整个数组，和大于0时--j，否则++k。复杂度直接O(n^2)，但对于重复数字的处理有点小麻烦|

- [X] 0016

|N-Sum问题|
|:--|
|和上一题类似，枚举中间的数i，用两个指针j，k从i开始向左向右遍历整个数组，和大于target时--j，否则++k
这样的做法也相当于用i，j遍历nums中的二元组，维护一个k，利用其局部性（固定i，j，当前最优解在上次最优解k的邻域内）求得答案
因为题目说最优解唯一，省掉了处理重复数字的过程，写起来就很简单了
一定会列举到最优解的证明：因为i，j会遍历所有下标二元组，当i，j访问最优解i，j，k_opt时，只有k > k_opt才会错过最优解
k > k_opt说明存在j' < j，访问i，j'时和小于target使得k一直递增并超过k_opt。此时必然有nums[i]+nums[j']+nums[k_opt] < target
而nums[i]+nums[j] <= nums[i]+nums[j']，从而nums[i]+nums[j]+nums[k_opt] <= nums[i]+nums[j']+nums[k_opt] < target
无论如何，i，j'，k_opt是更优的解，这与i，j，k_opt是最优解矛盾|

- [X] 0017

|组合|
|:--|
|枚举组合，轻松一刻（输入可能为空，判断一下即可）|

- [X] 0018

|N-Sum问题|
|:--|
|和3Sum是一样的道理，枚举i，j，k并利用局部性求最后一个下标l，复杂度O(n^3)
可以剪一下枝，常数会下降一些|

- [X] 0019

|链表|
|:--|
|又一道链表水题。花式过题了|

- [X] 0020

|栈，括号匹配|
|:--|
|括号匹配的问题很多都是用栈解决的|

- [X] 0021

|归并排序|
|:--|
|链表版的手写归并排序|

- [X] 0022

|栈，括号匹配|
|:--|
|又是括号匹配，因为只有一种括号，生成时甚至只需要记录栈高度即可|

- [X] 0023

|拓扑排序|
|:--|
|典型的拓扑排序。用堆维护当前最小值的话，复杂度为O(nlogk)
顺便吐槽一下LeetCode的坑爹边界条件，输入可能是空也就算了，数组里的链表表头也可能为空，真是够了|

- [X] 0024

|链表|
|:--|
|TOO MUCH WATER|

- [X] 0025

|链表|
|:--|
|水|

- [X] 0026

|数组|
|:--|
|维护Offset变量，每次从数组后部取不同的值填到前部|

- [X] 0027

|数组|
|:--|
|和上一题一样，维护一个Offset变量即可|

- [X] 0028

|字符串查找，[KMP算法](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)|
|:--|
|KMP算法模板题。手写KMP还是要记得原理的|

- [X] 0029

|位运算|
|:--|
|题目含含糊糊，说什么不准用乘、除和模求两数的商，其实就是想说用位运算和减法求商嘛
二进制数除法可以用左移+减法实现，和快速幂的原理差不多
另外，这题要求用32位整数实现32位除法，在几个极端值（尤其是INT_MIN）处要特殊判断一下|

- [X] 0030

|[AC自动机](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm)|
|:--|
|原先的方法用Trie树，枚举初始位置暴力判断过了，只能说数据编得不好没卡住
这次使用了（应该是正解的）AC自动机，先求出所有模式串的匹配结果（二元组，源串位置+AC自动机结点，其中结点保存了所有在此结点处结束的模式串序号组），再从匹配结果里枚举结束位置反推回去
细节上，反推时还可以对源串位置使用二分查找来进一步降低复杂度，不过目前这样已经足够过题了|

- [X] 0031

|排列|
|:--|
|几个事实：
1 一个数列是其中所有数集合的第一个排列的情况，当且仅当此数列从小到大排列；
2 一个数列是其中所有数集合的最后一个排列的情况，当且仅当此数列从大到小排列；
3 把一个数列尾部从大到小排列的最长子列变为从小到大排列，并将数列中紧贴此子列（但不属于此子列）的数与此子列中刚好大于它的数交换，即完成一次Next Permutation
举例：5 3 4 3 3 2 1 -> 5 3 1 2 3 3 4 -> 5 4 1 2 3 3 3
那么，实现它就可以了。题目要求算法是in-place（原地）的，而交换操作和二分查找都满足要求，所以没有问题|

- [X] 0032

|栈，括号匹配|
|:--|
|凡是括号匹配都可以考虑一下栈……
这次利用栈记录左括号的位置。特殊地，栈底保存可行序列的开始位置，相当于一个隐藏的左括号，以统一计算公式
可能更新答案的时机是遇到右括号和队尾，做到不重不漏即可|

- [X] 0033

|二分|
|:--|
|目标数组是“旋转”过的有序数组，大部分还是有序的。因为元素无重复，二分时多加几个条件判断，确定被搜索的数所在的区间即可
若没有“元素无重复”这个条件，复杂度就不能满足O(logn)的要求了，最坏情况是O(n)的|

- [X] 0034

|二分|
|:--|
|二分基础题，在可能有重复值的序列中求第一个某值和最后一个某值。拿来练手很不错|

- [X] 0035

|二分|
|:--|
|二分基础题，确定稍大一侧的坐标|

- [X] 0036

|位运算|
|:--|
|判断重复数字的模拟问题。这题我使用了比特位作为判重标志|

- [X] 0037

|搜索+剪枝，Dancing Links|
|:--|
|上次的解法是普通搜索+剪枝。剪枝主要是先填具有唯一可能的格子，然后在可能性最少的格子里搜索解
这次认真复习了Dancing Links（[一篇不错的博文](https://www.cnblogs.com/grenet/p/3145800.html)）
并且把数独问题转换成了DLX问题：
1 DLX 1~81列对应(x * 9 + y)，表示在数独坐标(x, y)处填数
2 DLX 82~162列对应(x * 9 + value)，表示在数独x行处填数字value
3 DLX 163~243列对应(y * 9 + value)，表示在数独y列处填数字value
4 DLX 244~324列对应(b * 9 + value)，表示在数独b块处填数字value
这样，一个完整的解就会完全且不重复地覆盖1~324列，就变为了DLX问题
不过直接用会TLE……一个是搜索树的大小问题，还有一个就是我在需要填的格子处把1~9都插入DLX里了，事实上这其中有些数字是不可能的
加上“每次搜索可能性最少的列”和“不插入不可能的行”这两个剪枝之后还是过了。感觉Dancing Links好处在写法规整，上次的解法我无论如何也不想再写一次了|

- [X] 0038

|模拟，递推|
|:--|
|纯模拟题……按照题意给出递推结果即可，甚至可以打表|

- [X] 0039

|搜索+剪枝，24点问题|
|:--|
|“24点问题”是我给“用几个数凑出一个目标数的搜索问题”起的外号
这类题的常用剪枝技巧包括
1 将数字从大到小排序来减小搜索树
2 利用部分和来裁掉不可能的选择支
3 利用题目约束（如所有数字都得用上）来选择最小的搜索树
POJ1011是这类题的代表|

- [X] 0040

|搜索+剪枝，24点问题|
|:--|
|同上一题，按题目要求多加一点约束条件就行了|

- [X] 0041

|桶排序|
|:--|
|桶排序后从1开始递增即可得到答案
题目要求O(n)时间和O(1)空间，前者桶排序已经满足（O(n)排序，O(m)搜索，m<=n），后者把输入的nums数组当成桶即可，但需要考虑越界和数字重复的情况|

- [X] 0042

|递推，漫水问题|
|:--|
|从这个角度去考虑：
1 首先在地形最左边和最右边各放一块无限高的挡板，此时里面的水无限多
2 抽掉最左边的挡板，从左到右递推水面高度
3 抽掉最右边的挡板，从右到左递推水面高度
剩下水的体积就是所求的答案了|

- [X] 0043

|高精度|
|:--|
|简单的高精度模拟|

- [X] 0044

|动态规划|
|:--|
|又是一道正则表达式匹配问题，做法同0010，注意考虑空串和*的匹配|

- [X] 0045

|递推|
|:--|
|基本的思路是用当前格子的跳跃步数更新所有可跳跃到的格子的步数，此时时间复杂度O(n*max(nums))
优化更新步骤，从后往前更新，一旦某个可跃到的格子步数更小，则停止更新。时间复杂度缩减到O(n)|

- [X] 0046

|排列|
|:--|
|题意就是枚举所有排列。时间复杂度O(n!)|

- [X] 0047

|排列|
|:--|
|枚举带有重复数字的排列，先预处理一下即可。时间复杂度上界O(n!)|

- [X] 0048

|图像处理|
|:--|
|旋转90度只需要循环交换对应位置的四个数即可。注意n为奇数时的处理（i < n / 2, j <= n / 2）|

- [X] 0049

|字符串|
|:--|
|找出字符组成相同的字符串并组队。简单的做法就是给字符排序，快排或桶排都行|

- [X] 0050

|快速幂|
|:--|
|题意就是用快速幂。注意幂次的正负号，以及INT_MIN|

- [X] 0051

|搜索，N皇后问题|
|:--|
|经典N皇后问题，无需剪枝的搜索。记录列、斜线、反斜线的使用情况，逐行搜索即可|

- [X] 0052

|搜索，N皇后问题|
|:--|
|跟上一题完全一致……买一赠一|

- [X] 0053

|动态规划/贪心，分治|
|:--|
|第一种做法（动态规划/贪心），递推式为
`f[i] = f[i-1] < 0 ? 0 : f[i-1] + nums[i]`
答案取最大的f[i]即可。这个做法策略是只要部分和 >= 0就保留（可能往更大的数字走），否则放弃当前的部分和。虽然确实是动态规划，但策略上来说还是很“贪心”的。
正确性可证。当i到达正解左边界时，之前的部分和一定 < 0，否则正解可以更大，故左边界没有问题；在正解内部如果有部分和 < 0，此时把正解分为三部分left，i，right，i是导致正解部分和 < 0的那一位，则ans = left + i + right < right，与正解是最大值矛盾。综上，这样的做法一定会遍历到正解，故结果正确
题目要求的第二种做法（分治）我做了半天，最后在LeetCode讨论区大神的指点下完成了
分治时记录四个数据：s0当前区间的最大部分和，s1当前区间从左边开始最大的部分和，s2当前区间从右边开始最大部分和，s3整个区间的和
设区间r分为两个区间left，right，则
`r.s0 = max(left.s2 + right.s1, max(left.s0, right.s0))`
`r.s1 = max(left.s1, left.s3 + right.s1)`
`r.s2 = max(right.s2, right.s3 + left.s2)`
`r.s3 = left.s3 + right.s3`
s1，s2，s3的计算都很好理解，s0的思路是这样的：分治时中间部分被切断了，所以它也可能产生最大部分和。这个中间部分最大部分和如何求出？用左边的s2加右边的s1。正确性可证。若正解位于左右区间，则取左右区间的s0即可；若正解横跨中线，单看右区间，若正解右边部分比s1大，则与s1是右区间从左开始最大部分和矛盾；左区间同理，故正解 <= 左边的s2 + 右边的s1，等号可取，故得证
之前我的做法是从中线开始向左向右扩展，以期求得中间部分最大部分和。但有一个问题，左右指针指向的元素大小相同时，没有策略（先扩展左指针/先扩展右指针）能够保证枚举到正解；而且时间复杂度上也增加了一个n的因子。思路上的主要问题是没有意识到求中线左右部分和的任务也可以交给分治，或者说认为分治只需要求最大部分和即可。学习了|

- [X] 0054

|模拟|
|:--|
|纯模拟题也出幺蛾子……用了lambda表达式之后在不存在的行数（大于所用行数）上报编译错误，醉了。解题时按题意要求来模拟即可|

- [X] 0055

|递推|
|:--|
|跟0045完全一致，买一送一……算了复制+修改一下吧
基本的思路是若当前格子可达，更新所有可跳跃到的格子的可达性，此时时间复杂度O(n*max(nums))
优化更新步骤，从后往前更新，一旦某个可跃到的格子已经可达，则停止更新。时间复杂度缩减到O(n)|

- [ ] 0056

||
|:--|
||