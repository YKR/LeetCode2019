# LeetCode2019 0001-0100

- [X] 0001\
花式过题。基本思路是从大到小排序后，两指针i，j分别从nums的头部和尾部开始扫描\
1 如果 nums[i] + nums[j] > target，则++i\
2 如果 nums[i] + nums[j] < target，则--j\
3 如果相等就返回输出。\
上一次的做法是构造(nums[i], i)为元素的vector并快速排序\
这一次本来想使用lambda表达式排序，但是爆内存了（可能是Lambda表达式的问题？）\
于是利用map是平衡树的特点，把(nums[i], i)塞进树里，随机访问时就已经排好序了（不过map是红黑树，时间效率上差一点）\
但是map中不能存在相同的键，所以实际上把它的value类型变成了vector。此时可能会有i == j的情况，需要特殊判断一下
- [X] 0002\
链表，没什么算法可写。需要注意边界条件，比如前导0
- [X] 0003\
基本思路是扫描字符串时记录扫描过的字符的位置。\
当访问一个新字符x时，递增当前累积子串ss的长度len；若ss中存在x，则将len变为curr[x] - last[x]。每一步用len更新ans\
这一次使用了map记录字符位置，时间效率O(nlogn)。事实上用桶排序思路的话（字符只有256个），可以把logn项缩减掉
- [X] 0004\
可以手写归并排序，时间O(m+n)，好处是容易写\
最优解思路是：令nums1为nums1、nums2中size较小的那一个，目的是从nums1中取出x个数，nums2中取出half-x个数（half是总数的一半），使得取出来的数组成了nums1+nums2中小的一半，此时未取出的数自然是nums1+nums2中大的一半，那么根据有序性至多只需要比较四个数的大小即可\
此时可以二分x，故时间为O(log(min(m,n)))。坏处是边界条件很头疼
- [X] 0005\
一般解法是O(n^2)的，包括上次的暴力枚举对称中心和这次的dp\
官方正解里有一个叫[Manacher's Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)的算法\
<**TODO**>: 了解并阐述Manacher's Algorithm
- [X] 0006\
纯粹的字符串处理题，就偷懒复制上次的代码了。不过要写得简短有效还是不容易的。
- [X] 0007\
简单的数字题，有一点位运算内容。主要问题是在只能使用32位整数时，如何判断溢出\
我的解法通过把乘法拆分为左移，对每一步左移做判断来避免溢出。官方正解是判断当前数字与INT_MAX/10的大小\
其实可以在汇编里判断溢出标志位吧……
- [X] 0008\
相当于上一题的扩展，抛开white space和正负号，还是只能使用32位整数时怎么判断溢出的问题
- [X] 0009\
判断回文数字，负数被排除了，如果用“倒序数字”是否等于“原数字”来判断，只需要考虑溢出问题。然而这题没限制32位，直接long long搞定\
这题的小要求“不把数字转换成字符串”，那么把数字转成vector也可以吧……
- [X] 0010\
正则表达式匹配相当于寻找一个自动机状态序列，似乎只能用动态规划？
- [X] 0011\
这次的解法是根据挡板高度从大到小排序，遍历挡板时记录扫描过的挡板的x坐标最大值和最小值，用当前挡板高度乘以（x最大值-x最小值）更新答案。因为扫描到当前挡板时，x坐标最大/最小的挡板的高度一定不低于当前挡板，所以当前答案是可能的；而且确实会枚举到使当前答案=正确答案的情况，所以算法正确。时间复杂度O(nlogn)\
更优的做法是一种贪心法。使两指针i，j分别从height头尾开始扫描，当height[i] < height[j]时++i，否则--j；用min(height[i], height[j]) * (j - i)更新答案。这样做一定会列举到正确答案的原因是：当i到达正确答案左边挡板l时，j只可能位于正确答案右边挡板r或之外，否则因为--j的情况只会发生在height[i] >= height[j]时，则存在l' < l且height[l'] >= height[r]，从而(l', r)组成的挡板是更优的解。时间复杂度O(n)
- [X] 0012\
简单模拟，轻松一刻，花式过题