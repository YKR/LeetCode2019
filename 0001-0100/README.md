# LeetCode2019 0001-0100

- [X] 0001

|N-Sum问题|
|:--|
|花式过题。基本思路是从大到小排序后，两指针i，j分别从nums的头部和尾部开始扫描
1 如果 nums[i] + nums[j] > target，则++i
2 如果 nums[i] + nums[j] < target，则--j
3 如果相等就返回输出。
上一次的做法是构造(nums[i], i)为元素的vector并快速排序
这一次本来想使用lambda表达式排序，但是爆内存了（可能是Lambda表达式的问题？）
于是利用map是平衡树的特点，把(nums[i], i)塞进树里，随机访问时就已经排好序了（不过map是红黑树，时间效率上差一点）
但是map中不能存在相同的键，所以实际上把它的value类型变成了vector。此时可能会有i == j的情况，需要特殊判断一下|

- [X] 0002

|链表|
|:--|
|链表，没什么算法可写。需要注意边界条件，比如前导0|

- [X] 0003

|字符串|
|:--|
|基本思路是扫描字符串时记录扫描过的字符的位置。
当访问一个新字符x时，递增当前累积子串ss的长度len；若ss中存在x，则将len变为curr[x] - last[x]。每一步用len更新ans
这一次使用了map记录字符位置，时间效率O(nlogn)。事实上用桶排序思路的话（字符只有256个），可以把logn项缩减掉|

- [X] 0004

|二分|
|:--|
|可以手写归并排序，时间O(m+n)，好处是容易写
最优解思路是：令nums1为nums1、nums2中size较小的那一个，目的是从nums1中取出x个数，nums2中取出half-x个数（half是总数的一半），使得取出来的数组成了nums1+nums2中小的一半，此时未取出的数自然是nums1+nums2中大的一半，那么根据有序性至多只需要比较四个数的大小即可
此时可以二分x，故时间为O(log(min(m,n)))。坏处是边界条件很头疼|

- [X] 0005

|动态规划，最长回文子串问题|
|:--|
|一般解法是O(n^2)的，包括上次的暴力枚举对称中心和这次的dp
官方正解里有一个叫[Manacher's Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)的算法
<**TODO**>: 了解并阐述Manacher's Algorithm|

- [X] 0006

|字符串|
|:--|
|纯粹的字符串处理题，就偷懒复制上次的代码了。不过要写得简短有效还是不容易的。|

- [X] 0007

|整数|
|:--|
|简单的数字题，有一点位运算内容。主要问题是在只能使用32位整数时，如何判断溢出
我的解法通过把乘法拆分为左移，对每一步左移做判断来避免溢出。官方正解是判断当前数字与INT_MAX/10的大小
其实可以在汇编里判断溢出标志位吧……|

- [X] 0008

|整数|
|:--|
|相当于上一题的扩展，抛开white space和正负号，还是只能使用32位整数时怎么判断溢出的问题|

- [X] 0009

|整数|
|:--|
|判断回文数字，负数被排除了，如果用“倒序数字”是否等于“原数字”来判断，只需要考虑溢出问题。然而这题没限制32位，直接long long搞定
这题的小要求“不把数字转换成字符串”，那么把数字转成vector也可以吧……|

- [X] 0010

|动态规划|
|:--|
|正则表达式匹配相当于寻找一个自动机状态序列，似乎只能用动态规划？|

- [X] 0011

|贪心|
|:--|
|这次的解法是根据挡板高度从大到小排序，遍历挡板时记录扫描过的挡板的x坐标最大值和最小值，用当前挡板高度乘以（x最大值-x最小值）更新答案。因为扫描到当前挡板时，x坐标最大/最小的挡板的高度一定不低于当前挡板，所以当前答案是可能的；而且确实会枚举到使当前答案=正确答案的情况，所以算法正确。时间复杂度O(nlogn)
更优的做法是一种贪心法。使两指针i，j分别从height头尾开始扫描，当height[i] < height[j]时++i，否则--j；用min(height[i], height[j]) * (j - i)更新答案。这样做一定会列举到正确答案的原因是：当i到达正确答案左边挡板l时，j只可能位于正确答案右边挡板r或之外，否则因为--j的情况只会发生在height[i] >= height[j]时，则存在l' < l且height[l'] >= height[r]，从而(l', r)组成的挡板是更优的解。时间复杂度O(n)|

- [X] 0012

|字符串|
|:--|
|简单模拟，轻松一刻，花式过题|

- [X] 0013

|字符串|
|:--|
|罗马数字转回阿拉伯。遍历字符串，若上一个字符标识的数字小于当前字符的，表示的就是当前字符减上一个字符，就要减去两倍上一个字符的值。|

- [X] 0014

|字符串|
|:--|
|轻松一刻|

- [X] 0015

|N-Sum问题|
|:--|
|这次为了省事又把输入丢到map里去了（map用来排序和记录重复次数）。思路就是枚举两个数a和b，判断-(a+b)是否在nums里
目前的做法是O(n^2logn)的，当然也可以把内循环里map的查找操作换成unordered_map的查找，来强行让复杂度变为O(n^2)
上一次的做法是排序后枚举中间的数i，用两个指针j，k从i开始向左向右遍历整个数组，和大于0时--j，否则++k。复杂度直接O(n^2)，但对于重复数字的处理有点小麻烦|

- [X] 0016

|N-Sum问题|
|:--|
|和上一题类似，枚举中间的数i，用两个指针j，k从i开始向左向右遍历整个数组，和大于target时--j，否则++k
这样的做法也相当于用i，j遍历nums中的二元组，维护一个k，利用其局部性（固定i，j，当前最优解在上次最优解k的邻域内）求得答案
因为题目说最优解唯一，省掉了处理重复数字的过程，写起来就很简单了
一定会列举到最优解的证明：因为i，j会遍历所有下标二元组，当i，j访问最优解i，j，k_opt时，只有k > k_opt才会错过最优解
k > k_opt说明存在j' < j，访问i，j'时和小于target使得k一直递增并超过k_opt。此时必然有nums[i]+nums[j']+nums[k_opt] < target
而nums[i]+nums[j] <= nums[i]+nums[j']，从而nums[i]+nums[j]+nums[k_opt] <= nums[i]+nums[j']+nums[k_opt] < target
无论如何，i，j'，k_opt是更优的解，这与i，j，k_opt是最优解矛盾|

- [X] 0017

|组合|
|:--|
|枚举组合，轻松一刻（输入可能为空，判断一下即可）|

- [X] 0018

|N-Sum问题|
|:--|
|和3Sum是一样的道理，枚举i，j，k并利用局部性求最后一个下标l，复杂度O(n^3)
可以剪一下枝，常数会下降一些|

- [X] 0019

|链表|
|:--|
|又一道链表水题。花式过题了|

- [X] 0020

|栈，括号匹配|
|:--|
|括号匹配的问题很多都是用栈解决的|

- [X] 0021

|归并排序|
|:--|
|链表版的手写归并排序|

- [X] 0022

|栈，括号匹配|
|:--|
|又是括号匹配，因为只有一种括号，生成时甚至只需要记录栈高度即可|

- [X] 0023

|拓扑排序|
|:--|
|典型的拓扑排序。用堆维护当前最小值的话，复杂度为O(nlogk)
顺便吐槽一下LeetCode的坑爹边界条件，输入可能是空也就算了，数组里的链表表头也可能为空，真是够了|

- [X] 0024

|链表|
|:--|
|TOO MUCH WATER|

- [X] 0025

|链表|
|:--|
|水|

- [X] 0026

|数组|
|:--|
|维护Offset变量，每次从数组后部取不同的值填到前部|

- [X] 0027

|数组|
|:--|
|和上一题一样，维护一个Offset变量即可|

- [X] 0028

|字符串查找，[KMP算法](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)|
|:--|
|KMP算法模板题。手写KMP还是要记得原理的|

- [X] 0029

|位运算|
|:--|
|题目含含糊糊，说什么不准用乘、除和模求两数的商，其实就是想说用位运算和减法求商嘛
二进制数除法可以用左移+减法实现，和快速幂的原理差不多
另外，这题要求用32位整数实现32位除法，在几个极端值（尤其是INT_MIN）处要特殊判断一下|

- [X] 0030

|[AC自动机](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm)|
|:--|
|原先的方法用Trie树，枚举初始位置暴力判断过了，只能说数据编得不好没卡住
这次使用了（应该是正解的）AC自动机，先求出所有模式串的匹配结果（二元组，源串位置+AC自动机结点，其中结点保存了所有在此结点处结束的模式串序号组），再从匹配结果里枚举结束位置反推回去
细节上，反推时还可以对源串位置使用二分查找来进一步降低复杂度，不过目前这样已经足够过题了|

- [X] 0031

|排列|
|:--|
|几个事实：
1 一个数列是其中所有数集合的第一个排列的情况，当且仅当此数列从小到大排列；
2 一个数列是其中所有数集合的最后一个排列的情况，当且仅当此数列从大到小排列；
3 把一个数列尾部从大到小排列的最长子列变为从小到大排列，并将数列中紧贴此子列（但不属于此子列）的数与此子列中刚好大于它的数交换，即完成一次Next Permutation
举例：5 3 4 3 3 2 1 -> 5 3 1 2 3 3 4 -> 5 4 1 2 3 3 3
那么，实现它就可以了。题目要求算法是in-place（原地）的，而交换操作和二分查找都满足要求，所以没有问题|

- [X] 0032

|栈，括号匹配|
|:--|
|凡是括号匹配都可以考虑一下栈……
这次利用栈记录左括号的位置。特殊地，栈底保存可行序列的开始位置，相当于一个隐藏的左括号，以统一计算公式
可能更新答案的时机是遇到右括号和队尾，做到不重不漏即可|

- [X] 0033

|二分|
|:--|
|目标数组是“旋转”过的有序数组，大部分还是有序的。因为元素无重复，二分时多加几个条件判断，确定被搜索的数所在的区间即可
若没有“元素无重复”这个条件，复杂度就不能满足O(logn)的要求了，最坏情况是O(n)的|

- [X] 0034

|二分|
|:--|
|二分基础题，在可能有重复值的序列中求第一个某值和最后一个某值。拿来练手很不错|

- [X] 0035

|二分|
|:--|
|二分基础题，确定稍大一侧的坐标|

- [X] 0036

|位运算|
|:--|
|判断重复数字的模拟问题。这题我使用了比特位作为判重标志|

- [X] 0037

|搜索+剪枝，Dancing Links|
|:--|
|上次的解法是普通搜索+剪枝。剪枝主要是先填具有唯一可能的格子，然后在可能性最少的格子里搜索解
这次认真复习了Dancing Links（[一篇不错的博文](https://www.cnblogs.com/grenet/p/3145800.html)）
并且把数独问题转换成了DLX问题：
1 DLX 1~81列对应(x * 9 + y)，表示在数独坐标(x, y)处填数
2 DLX 82~162列对应(x * 9 + value)，表示在数独x行处填数字value
3 DLX 163~243列对应(y * 9 + value)，表示在数独y列处填数字value
4 DLX 244~324列对应(b * 9 + value)，表示在数独b块处填数字value
这样，一个完整的解就会完全且不重复地覆盖1~324列，就变为了DLX问题
不过直接用会TLE……一个是搜索树的大小问题，还有一个就是我在需要填的格子处把1~9都插入DLX里了，事实上这其中有些数字是不可能的
加上“每次搜索可能性最少的列”和“不插入不可能的行”这两个剪枝之后还是过了。感觉Dancing Links好处在写法规整，上次的解法我无论如何也不想再写一次了|

- [X] 0038

|模拟，递推|
|:--|
|纯模拟题……按照题意给出递推结果即可，甚至可以打表|

- [X] 0039

|搜索+剪枝，24点问题|
|:--|
|“24点问题”是我给“用几个数凑出一个目标数的搜索问题”起的外号
这类题的常用剪枝技巧包括
1 将数字从大到小排序来减小搜索树
2 利用部分和来裁掉不可能的选择支
3 利用题目约束（如所有数字都得用上）来选择最小的搜索树
POJ1011是这类题的代表|

- [X] 0040

|搜索+剪枝，24点问题|
|:--|
|同上一题，按题目要求多加一点约束条件就行了|

- [X] 0041

|桶排序|
|:--|
|桶排序后从1开始递增即可得到答案
题目要求O(n)时间和O(1)空间，前者桶排序已经满足（O(n)排序，O(m)搜索，m<=n），后者把输入的nums数组当成桶即可，但需要考虑越界和数字重复的情况|

- [X] 0042

|递推，漫水问题|
|:--|
|从这个角度去考虑：
1 首先在地形最左边和最右边各放一块无限高的挡板，此时里面的水无限多
2 抽掉最左边的挡板，从左到右递推水面高度
3 抽掉最右边的挡板，从右到左递推水面高度
剩下水的体积就是所求的答案了|

- [X] 0043

|高精度|
|:--|
|简单的高精度模拟|

- [X] 0044

|动态规划|
|:--|
|又是一道正则表达式匹配问题，做法同0010，注意考虑空串和*的匹配|

- [X] 0045

|递推|
|:--|
|基本的思路是用当前格子的跳跃步数更新所有可跳跃到的格子的步数，此时时间复杂度O(n*max(nums))
优化更新步骤，从后往前更新，一旦某个可跃到的格子步数更小，则停止更新。时间复杂度缩减到O(n)|

- [X] 0046

|排列|
|:--|
|题意就是枚举所有排列。时间复杂度O(n!)|

- [X] 0047

|排列|
|:--|
|枚举带有重复数字的排列，先预处理一下即可。时间复杂度上界O(n!)|

- [X] 0048

|图像处理|
|:--|
|旋转90度只需要循环交换对应位置的四个数即可。注意n为奇数时的处理（i < n / 2, j <= n / 2）|

- [X] 0049

|字符串|
|:--|
|找出字符组成相同的字符串并组队。简单的做法就是给字符排序，快排或桶排都行|

- [X] 0050

|快速幂|
|:--|
|题意就是用快速幂。注意幂次的正负号，以及INT_MIN|

- [X] 0051

|搜索，N皇后问题|
|:--|
|经典N皇后问题，无需剪枝的搜索。记录列、斜线、反斜线的使用情况，逐行搜索即可|

- [X] 0052

|搜索，N皇后问题|
|:--|
|跟上一题完全一致……买一赠一|

- [X] 0053

|动态规划/贪心，分治|
|:--|
|第一种做法（动态规划/贪心），递推式为
`f[i] = f[i-1] < 0 ? 0 : f[i-1] + nums[i]`
答案取最大的f[i]即可。这个做法策略是只要部分和 >= 0就保留（可能往更大的数字走），否则放弃当前的部分和。虽然确实是动态规划，但策略上来说还是很“贪心”的。
正确性可证。当i到达正解左边界时，之前的部分和一定 < 0，否则正解可以更大，故左边界没有问题；在正解内部如果有部分和 < 0，此时把正解分为三部分left，i，right，i是导致正解部分和 < 0的那一位，则ans = left + i + right < right，与正解是最大值矛盾。综上，这样的做法一定会遍历到正解，故结果正确
题目要求的第二种做法（分治）我做了半天，最后在LeetCode讨论区大神的指点下完成了
分治时记录四个数据：s0当前区间的最大部分和，s1当前区间从左边开始最大的部分和，s2当前区间从右边开始最大部分和，s3整个区间的和
设区间r分为两个区间left，right，则
`r.s0 = max(left.s2 + right.s1, max(left.s0, right.s0))`
`r.s1 = max(left.s1, left.s3 + right.s1)`
`r.s2 = max(right.s2, right.s3 + left.s2)`
`r.s3 = left.s3 + right.s3`
s1，s2，s3的计算都很好理解，s0的思路是这样的：分治时中间部分被切断了，所以它也可能产生最大部分和。这个中间部分最大部分和如何求出？用左边的s2加右边的s1。正确性可证。若正解位于左右区间，则取左右区间的s0即可；若正解横跨中线，单看右区间，若正解右边部分比s1大，则与s1是右区间从左开始最大部分和矛盾；左区间同理，故正解 <= 左边的s2 + 右边的s1，等号可取，故得证
之前我的做法是从中线开始向左向右扩展，以期求得中间部分最大部分和。但有一个问题，左右指针指向的元素大小相同时，没有策略（先扩展左指针/先扩展右指针）能够保证枚举到正解；而且时间复杂度上也增加了一个n的因子。思路上的主要问题是没有意识到求中线左右部分和的任务也可以交给分治，或者说认为分治只需要求最大部分和即可。学习了|

- [X] 0054

|模拟|
|:--|
|纯模拟题也出幺蛾子……用了lambda表达式之后在不存在的行数（大于所用行数）上报编译错误，醉了。解题时按题意要求来模拟即可|

- [X] 0055

|递推|
|:--|
|跟0045完全一致，买一送一……算了复制+修改一下吧
基本的思路是若当前格子可达，更新所有可跳跃到的格子的可达性，此时时间复杂度O(n*max(nums))
优化更新步骤，从后往前更新，一旦某个可跃到的格子已经可达，则停止更新。时间复杂度缩减到O(n)|

- [X] 0056

|模拟|
|:--|
|区间合并，优先下界排序，判断区间和前一个是否重合即可|

- [X] 0057

|模拟|
|:--|
|同样是区间合并，判定插入位置即可|

- [X] 0058

|字符串|
|:--|
|需要注意字符串末尾的空格，它们是需要被去掉的……
但是，这道题算什么？入门C++题吗？
TOO MUCH WATER|

- [X] 0059

|模拟|
|:--|
|TOO MUCH WATER|

- [X] 0060

|排列|
|:--|
|每次用K除以(n-1)!确定当前位数字，余数进入下一轮判定|

- [X] 0061

|链表|
|:--|
|TOO MUCH WATER|

- [X] 0062

|动态规划|
|:--|
|递推方程`f[i][j] = f[i-1][j] + f[i][j-1]`|

- [X] 0063

|动态规划|
|:--|
|基本同上题，递推方程`f[i][j] = (1 - obstacle[i][j]) * (f[i-1][j] + f[i][j-1])`|

- [X] 0064

|动态规划|
|:--|
|递推方程`f[i][j] = min{f[i-1][j], f[i][j-1]} + g[i][j]`|

- [X] 0065

|字符串|
|:--|
|出题人脑子有坑系列，匹配规则不明说，让人自己跑几遍看边界条件，边界条件还跟cin >> double不一样，真的气人，建议差评|

- [X] 0066

|高精度|
|:--|
|弱化版整数高精度，实现+1……无语|

- [X] 0067

|高精度|
|:--|
|高精度加法，二进制版|

- [X] 0068

|字符串|
|:--|
|字符串格式处理，按题目要求来就行|

- [X] 0069

|二分|
|:--|
|求整数平方根，这题我用的是二分。需要注意的是输入数据可能达到INT_MAX。
LeetCode评论区还有用牛顿法解的……大家都喜欢花式过题么|

- [X] 0070

|动态规划，斐波那契数列|
|:--|
|递推方程`f[i] = f[i-1] + f[i-2]`，f[1] == 1，f[2] == 2，那么就是斐波那契数列了
求法包括暴力DP、通项公式、矩阵乘法+快速幂等。这次我用的是矩阵乘法+快速幂，这也是一些数列问题的通用解法
然而……看了一下上次的代码，暴力DP也能过……|

- [X] 0071

|字符串|
|:--|
|计算绝对路径。注意这里把所有路径都当作从“/”目录开始的路径，所以“..”出现得太多时回退不会超过“/”|

- [X] 0072

|动态规划，最长公共子序列问题|
|:--|
|递推式`f[i][j] = min{ f[i-1][j] + 1, f[i][j-1] + 1, f[i-1][j-1] + (if word0[i-1] == word1[j-1] then 0 else 1) }`
注意到其实这题就是最长公共子序列问题。求出最长公共子序列的长度，剩下的部分取两者中更长的那一个就行了
这个问题在基于马尔可夫链假设的DNA模型中，判定两串DNA相似程度时也用到了|

- [X] 0073

|模拟|
|:--|
|这题的要求本身很简单，难点全在in-place的做法上
我的解法是：枚举每一行，在处理前一行的时候先记录本行是否有0，而暂不将前一行全变成0；处理后一行时，先将本行有0的列中行数小于本行的部分全变成0，那么此时前一行记录了所有列是否为0的信息，故可枚举前一行的所有元素，若为0则将本行对应元素变成0，最后再根据前一行原先是否有0决定是否把前一行全变成0。举例如下：
`1203` <- 本行有0，记录但暂时不把行元素全变0
`4050`
=> 枚举下一行
`1000`
`4050` <- 本行中的0往上推进
=>
`1000`
`4000` <- 上行的0推到本行
=>
`0000`
`4000` <- 上行有0，将上行全变0
=>
`0000`
`4000` <- 本行有0
=> 枚举下一行……|

- [X] 0074

|二分|
|:--|
|两次二分，一次按行的最后一位数字定位，一次按行元素大小定位。熟悉二分的话写起来很简单|

- [X] 0075

|桶排序|
|:--|
|因为数组元素取值为0、1、2，所以桶排序空间复杂度为常数，满足要求；要一次把数组排好的话，使用归纳法思路，当枚举到某个元素时，之前的元素一定已经排好序了，那么根据桶内元素个数可以算出各元素块的起点和终点，把数值大于或等于当前元素的元素块终点后移一位即可|

- [X] 0076

|滑动窗口|
|:--|
|题目要求是找出S中包含所有T中字符的最短子串，注意到T中字符可能有重复，故不能用单个bit来表示字符是否存在。
我的做法是滑动窗口。维护一个当前窗口字符数量的“桶”（和桶排序的“桶”是一个意思），若桶里所有T中字符的数量都大于或等于它们在T中的数量，则此滑动窗口是合法的
具体到滑动窗口本身，我维护了一个总字符数X，表示窗口中T中字符不超过T中数量部分的和（例：T中字符ABC，数量1/3/1，S中数量3/2/1，则X == min(1, 3) + min(3, 2) + min(1, 1) == 4），当X == T中字符总数时，当前窗口合法。合法的窗口需要尽量短，则减去最左边的元素直到最左边的元素是必要的为止。易证这个策略是不重不漏的。
这样，总体的时间复杂度为O(n)，n为s的长度|

- [X] 0077

|组合|
|:--|
|枚举1~n中长度为k的组合
TOO MUCH WATER|

- [X] 0078

|集合|
|:--|
|枚举一个非重复集的所有子集
TOO MUCH WATER|

- [X] 0079

|搜索|
|:--|
|从二维矩阵里搜索一个连续的字符串，两格点“连续”定义为四个方向相邻
普通暴力搜索就可以了，DFS、BFS皆可|

- [X] 0080

|数组|
|:--|
|去掉有序数组中的多余重复数字，使数组中每个数字的数量不超过2，要求In-place
这题跟普通的“去掉多余数字”是一样的，多加一个判断（当前数字的数量达到2）即可|

- [X] 0081

|二分，遍历，时间复杂度分析|
|:--|
|二分方法参考0033，但当存在重复的数时，对于nums[l] == nums[mid] == nums[r]的情况无法确定旋转的端点在哪里，此时最坏时间复杂度退化为O(n)
既然如此，我这里直接就O(n)遍历了。其实也可以写二分，特殊处理上面的那种情况即可|

- [X] 0082

|链表|
|:--|
|判断重复数字，若有重复移除全部。链表操作，没什么可说的……|

- [X] 0083

|链表|
|:--|
|判断重复数字，移除多余的数字
至今为止，LeetCode里的链表题都是水题……|

- [X] 0084

|并查集，栈，01图最大矩形面积问题|
|:--|
|一开始看到这题还以为跟0011的题意是一个意思，于是按高度从大到小排序，然后一一列举。但是这次就不是简单维护最大下标和最小下标的事了，需要用并查集求出所在的区间大小，再以当前的高度和区间大小更新答案。因为是从大到小枚举的，故求得的当前区间中所有元素的高度一定大于或等于当前元素，而区间之外的元素高度一定小于或等于当前元素，故正确性易证。时间复杂度是排序的O(nlogn)
但是，看了上次的解法我才反应过来，这题也可以用这种策略来做：
1 维护一个栈，栈中元素是heights数组的下标，一开始为空，保证其中的元素高度从栈底到栈顶单调递增
2 列举heights的元素。对于每个元素，
2.1 若栈顶元素的高度大于当前元素高度，则说明以栈顶元素为最小高度的区间到当前元素为止，故以栈顶元素为最小高度的区间为[栈顶之下的元素 + 1, 当前元素 - 1]，以区间长度和栈顶元素高度更新答案。
2.2 既然栈顶元素已经处理完了，从栈里弹出栈顶元素，之后重复2.1直到栈顶元素小于当前元素即可（此判断条件也保持了栈中元素高度单调增的特点）
退出循环后还需要处理栈中剩下的元素，其意义是以它们为最小高度的区间上界达到了heights末尾。一个省事的做法是预先在heights末尾压入一个0，这样它们就能在循环中被处理了
总体来说，这个方法的时间复杂度为O(n)，优于排序的方法|

- [X] 0085

|栈，01图最大矩形面积问题|
|:--|
|与上一题紧密相关。遍历每一行时更新当前行的heights数组，然后直接使用上一题的代码即可|

- [X] 0086

|链表|
|:--|
|归并排序中的一小步，链表版|

- [X] 0087

|递归，排序|
|:--|
|局部性：当两字符串是扰动关系时，它们对应左右子串的字符构成是相同的
枚举左右子串分界位置，当出现两子串具有相同字符构成时，认为此分界位置可能可行，递归验证左右子串的对应关系
判定“相同字符构成”需要用到排序，此处我用的是桶排，推测插入排序的时间消耗会更少|

- [X] 0088

|归并排序|
|:--|
|归并排序的一小步
题目没提In-place，姑且当它提了，做法是从后往前遍历时做归并|

- [X] 0089

|递推，位运算|
|:--|
|`i & -i`取到的是i的二进制表示中最低位的1，这是-i的编码方式（补码）决定的
观察题目要求，由递推式`f[i] = f[i - 1] ^ (i & -i)`生成的序列是满足要求的
题目要求中似乎漏了“对任意n，其灰码必须包含[0, 1 << n)中的所有数字”，姑且认为它提了这点。关于递推方法的正确性证明如下：（归纳法）
1 n == 0完备
2 n == k - 1时完备，当n == k时，令ik = 1 << n，则f[ik] = f[ik - 1] ^ (ik & -ik) == f[ik - 1] ^ ik，而这是唯一一次修改f[i]中二进制第n位的操作，且对于i > ik，所有的操作与i < ik的部分对称，故由归纳法和对称性i > ik的部分第0 ~ n - 1位是完备的。由二进制数的特点可知，n == k时0 ~ n位是完备的|

- [X] 0090

|组合|
|:--|
|枚举可重复集的所有子集
我的做法是先排序，然后在0078的基础上加了一个布尔变量，表示前一个数有没有被加入到集合里。若加入了，当前的数可以选择加入或不加入；否则若当前的数等于之前的数，则只能选择不加入。这样就保证了对于任意k，重复数字加入k次的情况只会被搜索一次，故结果正确|

- [X] 0091

|动态规划|
|:--|
|递推方程为：
`f[i] = (valid(i - 1) ? 0 : f[i - 1]) + (valid(i - 2) ? 0 : f[i - 2])`
其中valid为判定合法的函数，一位数valid(i - 1)的合法范围是1 ~ 9，两位数valid(i - 2)的合法范围是10 ~ 26（不能有前导0）
之前和这次的WA意外的多，还是出在对0的处理上|

- [X] 0092

|链表|
|:--|
|反转部分链表，要求一遍完成。用两个指针扫描链表即可|

- [X] 0093

|搜索|
|:--|
|题意是给一串数字加点，使其形成合法的IP地址。纯搜索题，注意处理数字0（不能有连续0和前导0等）即可|

- [X] 0094

|递归，栈|
|:--|
|中序遍历输出结点的值，要求用循环来做，那么用栈结构模拟递归即可|

- [X] 0095

|递推，搜索|
|:--|
|由于树结构具有自相似的特点，故较适合递推，方法为
`f[n] = (i, f[i - 1], f[n - i - 1] + i)`
其中三元组(a,b,c)表示a为根，b为左子树集，c为右子树集，所产生的所有二叉树；f[n]表示结点数为n时所有可能的BST树；f[n]+x表示给f[n]中所有BST树所有结点的值增加x后的集合
我的代码直接使用动态分配的二叉树作为f的元素，考虑到复制一个二叉树的实际时间代价较大，也可以使用先序遍历结果作为f的元素，返回最终结果时再生成树结构|

- [X] 0096

|递推|
|:--|
|跟上一题几乎相同，只不过要求输出的是可能的BST树的数量，这就更适合递推了|

- [X] 0097

|动态规划|
|:--|
|这题暴力竟然能过，虽然时间消耗非常巨大……不过可以把暴力改成记忆化搜索，也是动规
判断第三个字符串是不是前两个字符串的“交错”，其实是正则表达式匹配的弱化版，写一个类似的动态规划即可解决|

- [X] 0098

|二叉搜索树|
|:--|
|判断一个BST是否合法就看它左子树的区间上界是否小于它的值，及它右子树的区间下界是否大于它的值。递归查找即可|

- [X] 0099

|二叉搜索树|
|:--|
|BST的性质：中序遍历BST得到的序列是从小到大排列的
题目中提到输入BST中有两个数交换了，那么找出中序遍历中相隔最远的逆序对即可
要求常数空间，若递归占用的栈空间不算的话，在遍历时记录中序遍历位置最靠近当前结点的结点，比对值的大小即可|

- [X] 0100

|递归|
|:--|
|判定两棵二叉树完全一致。递归判断即可|